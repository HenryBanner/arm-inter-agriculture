#include "IHSys.h"
#include "uart.h"
#include "udp.h"
//
#define N 3
#define LED_D7	"/sys/kernel/gec_ctrl/led_d7"
#define LED_D8	"/sys/kernel/gec_ctrl/led_d8"
#define LED_D9	"/sys/kernel/gec_ctrl/led_d9"
#define LED_D10	"/sys/kernel/gec_ctrl/led_d10"
#define LED_ALL	"/sys/kernel/gec_ctrl/led_all"
#define BEEP 	"/sys/kernel/gec_ctrl/beep"

#define COM2	"/dev/ttySAC1"
#define COM3	"/dev/ttySAC2"
#define COM4	"/dev/ttySAC3"

int music_start = 0; //标记madplay是否占用



int lcd_fd;  //灯文件
int* plcd;  //像数文件
int bmp_fd; //图片文件
int led_fd; //显示屏文件

int width; //图片宽度
int height;//图片高度
int depth;//图片深度

char* p; //像素数组

int laizi1; //癞子
int total_bytes;//像素字节总数


int read_x = -1, read_y = -1; //x横y纵

int ret_x, ret_y;//x横y纵

int flag_cont_music = 1;//music状态
int music_count = 0;//MP3下标


unsigned char rbuf1[9];  //获取光照数据
unsigned char rbuf2[15]; //获取温湿度大气压海拔数据




int count = 2;		 //歌曲计数
int start_all = 1;   //进入主界面标记
int flag_light = 0;  //进入灯界面标记
int flag_mp3 = 0;    //进入音乐界面标记
int flag_dc = 0;     //进入测量面标记
int flag_on_off = 1; //灯的状态
int flag_light_sys = 1;  //灯驱动的状态

char number[][24 * 48 / 8] = {
	{/*--  文字:  0  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x01,0xFF,0x80,0x03,0xC3,
0xC0,0x07,0x81,0xE0,0x0F,0x81,0xF0,0x0F,0x00,0xF0,0x1F,0x00,0xF8,0x1F,0x00,0xF8,
0x1E,0x00,0x78,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,
0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,
0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,
0x3E,0x00,0x78,0x1F,0x00,0xF8,0x1F,0x00,0xF8,0x0F,0x00,0xF0,0x0F,0x81,0xF0,0x07,
0x81,0xE0,0x03,0xC3,0xC0,0x01,0xFF,0x80,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

 { /*--  文字:  1  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x1C,0x00,0x00,0x7C,
0x00,0x07,0xFC,0x00,0x07,0xFC,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,
0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,
0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,
0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,
0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,
0x3E,0x00,0x00,0x3E,0x00,0x07,0xFF,0xE0,0x07,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },


{ /*--  文字:  2  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x03,0xFF,0xC0,0x0F,0x83,
0xE0,0x0E,0x01,0xF0,0x1E,0x00,0xF8,0x1E,0x00,0xF8,0x3E,0x00,0x78,0x3E,0x00,0x78,
0x3F,0x00,0x78,0x3F,0x00,0x78,0x1F,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF0,0x00,
0x01,0xF0,0x00,0x01,0xE0,0x00,0x03,0xC0,0x00,0x07,0xC0,0x00,0x0F,0x80,0x00,0x0F,
0x00,0x00,0x1E,0x00,0x00,0x3C,0x00,0x00,0x78,0x00,0x00,0xF0,0x00,0x01,0xE0,0x00,
0x03,0xC0,0x00,0x07,0x80,0x1C,0x0F,0x00,0x1C,0x0E,0x00,0x38,0x1C,0x00,0x38,0x3C,
0x00,0x78,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{/*--  文字:  3  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x00,0x07,0xFF,0x80,0x0F,0x07,
0xC0,0x1E,0x03,0xE0,0x1E,0x01,0xF0,0x1E,0x01,0xF0,0x1F,0x00,0xF0,0x1F,0x00,0xF0,
0x1E,0x00,0xF0,0x00,0x00,0xF0,0x00,0x01,0xF0,0x00,0x01,0xF0,0x00,0x01,0xE0,0x00,
0x07,0xC0,0x00,0x1F,0x80,0x00,0xFE,0x00,0x00,0x7F,0x80,0x00,0x03,0xE0,0x00,0x01,
0xF0,0x00,0x00,0xF0,0x00,0x00,0xF8,0x00,0x00,0x78,0x00,0x00,0x7C,0x00,0x00,0x7C,
0x1E,0x00,0x7C,0x3F,0x00,0x7C,0x3F,0x00,0x78,0x3F,0x00,0xF8,0x3E,0x00,0xF8,0x1E,
0x01,0xF0,0x0F,0x03,0xE0,0x07,0xFF,0xC0,0x01,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{/*--  文字:  4  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x03,0xC0,0x00,0x07,
0xC0,0x00,0x0F,0xC0,0x00,0x0F,0xC0,0x00,0x1F,0xC0,0x00,0x1F,0xC0,0x00,0x3F,0xC0,
0x00,0x77,0xC0,0x00,0x77,0xC0,0x00,0xE7,0xC0,0x01,0xE7,0xC0,0x01,0xC7,0xC0,0x03,
0x87,0xC0,0x03,0x87,0xC0,0x07,0x07,0xC0,0x0E,0x07,0xC0,0x0E,0x07,0xC0,0x1C,0x07,
0xC0,0x3C,0x07,0xC0,0x38,0x07,0xC0,0x7F,0xFF,0xFC,0x7F,0xFF,0xFE,0x3F,0xFF,0xFC,
0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,
0x07,0xC0,0x00,0x07,0xC0,0x00,0x7F,0xFC,0x00,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{/*--  文字:  5  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xF8,0x0F,0xFF,0xF8,0x0F,0xFF,
0xF8,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,
0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x3E,0x00,0x0F,0xFF,0xC0,0x0F,
0xFF,0xE0,0x0F,0x83,0xF0,0x1F,0x01,0xF0,0x1E,0x00,0xF8,0x0C,0x00,0xF8,0x00,0x00,
0x78,0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,0x00,0x7C,0x1E,0x00,0x7C,
0x3F,0x00,0x7C,0x3F,0x00,0x78,0x3F,0x00,0x78,0x3E,0x00,0xF8,0x1E,0x00,0xF0,0x1E,
0x01,0xF0,0x0F,0x03,0xE0,0x07,0xFF,0xC0,0x01,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{/*--  文字:  6  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xC0,0x00,0xFF,0xE0,0x03,0xE1,
0xF0,0x03,0xC1,0xF8,0x07,0x81,0xF8,0x0F,0x01,0xF0,0x0F,0x00,0xE0,0x1E,0x00,0x00,
0x1E,0x00,0x00,0x3E,0x00,0x00,0x3E,0x00,0x00,0x3E,0x00,0x00,0x3E,0x3F,0x80,0x3E,
0xFF,0xE0,0x3F,0xF3,0xF0,0x3F,0xC1,0xF8,0x3F,0x80,0xF8,0x3F,0x00,0x7C,0x3E,0x00,
0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x3C,0x3E,0x00,0x3C,0x3E,0x00,0x3C,0x3E,0x00,0x3C,
0x3E,0x00,0x3C,0x3E,0x00,0x7C,0x1F,0x00,0x7C,0x1F,0x00,0x78,0x0F,0x80,0x78,0x0F,
0x80,0xF0,0x07,0xE1,0xE0,0x03,0xFF,0xC0,0x00,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{ /*--  文字:  7  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFC,0x1F,0xFF,0xFC,0x1F,0xFF,
0xF8,0x1F,0x00,0x78,0x1C,0x00,0x70,0x1C,0x00,0xF0,0x38,0x00,0xE0,0x38,0x01,0xE0,
0x00,0x01,0xC0,0x00,0x03,0xC0,0x00,0x03,0x80,0x00,0x07,0x80,0x00,0x07,0x00,0x00,
0x0F,0x00,0x00,0x0E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1C,0x00,0x00,0x3C,
0x00,0x00,0x3C,0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,0x00,0x78,0x00,0x00,0x78,0x00,
0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xFC,0x00,0x00,0xFC,0x00,0x00,
0xFC,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

{ /*--  文字:  8  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x07,0xFF,0xC0,0x0F,0x81,
0xE0,0x1F,0x00,0xF0,0x1E,0x00,0x78,0x3C,0x00,0x78,0x3C,0x00,0x78,0x3C,0x00,0x7C,
0x3C,0x00,0x7C,0x3E,0x00,0x78,0x1F,0x00,0x78,0x1F,0x80,0x70,0x0F,0xC0,0xF0,0x07,
0xF1,0xE0,0x03,0xFF,0xC0,0x01,0xFF,0x00,0x03,0xFF,0xC0,0x07,0x9F,0xE0,0x0F,0x07,
0xF0,0x1E,0x03,0xF0,0x3C,0x01,0xF8,0x3C,0x00,0xF8,0x3C,0x00,0x7C,0x7C,0x00,0x7C,
0x78,0x00,0x3C,0x78,0x00,0x3C,0x3C,0x00,0x3C,0x3C,0x00,0x78,0x3C,0x00,0x78,0x1E,
0x00,0xF0,0x0F,0x81,0xE0,0x07,0xFF,0xC0,0x01,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{ /*--  文字:  9  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x00,0x07,0xFF,0x80,0x0F,0x83,
0xC0,0x1F,0x01,0xE0,0x1E,0x00,0xF0,0x3E,0x00,0xF0,0x3C,0x00,0x78,0x3C,0x00,0x78,
0x7C,0x00,0x78,0x7C,0x00,0x7C,0x7C,0x00,0x7C,0x7C,0x00,0x7C,0x7C,0x00,0x7C,0x3C,
0x00,0x7C,0x3E,0x00,0xFC,0x3E,0x00,0xFC,0x3E,0x01,0xFC,0x1F,0x07,0xFC,0x0F,0xFF,
0x7C,0x07,0xFE,0x7C,0x01,0xF8,0x7C,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,
0x00,0x00,0xF8,0x00,0x00,0xF0,0x0E,0x01,0xF0,0x1F,0x01,0xE0,0x1F,0x03,0xE0,0x1F,
0x07,0xC0,0x1F,0x8F,0x80,0x0F,0xFF,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

{ /*--  文字:  .  --*/
/*--  宋体36;  此字体下对应的点阵为：宽x高=24x48   --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x1F,0x80,0x00,0x3F,
0xC0,0x00,0x3F,0xC0,0x00,0x1F,0x80,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }
};

char* mp3[7] = { "/root/music/music_list/01.mp3","/root/music/music_list/02.mp3",
		"/root/music/music_list/03.mp3" ,"/root/music/music_list/04.mp3" ,
		"/root/music/music_list/05.mp3" ,"/root/music/music_list/06.mp3" ,
		"/root/music/music_list/07.mp3" };

//初始化屏幕和映射
int init_lcd()
{
	//打开屏幕
	lcd_fd = open("/dev/fb0", O_RDWR);
	if (-1 == lcd_fd)
	{
		perror("open fail");
		return 0;
	}

	//映射
	plcd = mmap(NULL, 480 * 800 * 4, PROT_READ | PROT_WRITE, MAP_SHARED, lcd_fd, 0);
	if (NULL == plcd)
	{
		perror("mmap fail");
		return 0;
	}

	return 1;
}

//读取图片数据
int read_data(int i)
{
	bmp_fd = 0;
	char pch3[8] = { 0 };
	sprintf(pch3, "/root/bmp/p%d.bmp", i);
	printf("%s\n", pch3);

	bmp_fd = open(pch3, O_RDWR);
	if (-1 == bmp_fd)
	{
		perror("open bmp failed:");
		return 0;
	}
	//宽度
	width = 0;
	lseek(bmp_fd, 0x12, SEEK_SET);
	int ret = read(bmp_fd, &width, 4);
	if (-1 == ret)
	{
		printf("read width error.\n");
		return -1;
	}
	printf("width = %d\n", width);

	//高度
	height = 0;
	lseek(bmp_fd, 0x16, SEEK_SET);
	ret = read(bmp_fd, &height, 4);
	if (-1 == ret)
	{
		printf("read height error.\n");
		return -1;
	}
	printf("height = %d\n", height);

	//深度
	depth = 0;
	lseek(bmp_fd, 0x1c, SEEK_SET);
	ret = read(bmp_fd, &depth, 2);
	if (-1 == ret)
	{
		printf("read depth error.\n");
		return -1;
	}
	printf("depth = %d\n", depth);


	if (abs(width) * (depth / 8) % 4)
	{
		laizi1 = 4 - abs(width) * (depth / 8) % 4;
	}

	int line_bytes = laizi1 + abs(width) * (depth / 8);

	total_bytes = line_bytes * abs(height);


	p = (char*)realloc(p, total_bytes);
	if (p == NULL)
	{
		perror("realloc fail");
		return 0;
	}

	//读像素组
	lseek(bmp_fd, 0x36, SEEK_SET);
	int res = read(bmp_fd, p, total_bytes);
	if (-1 == res)
	{
		perror("read fail");
		return 0;
	}
	close(bmp_fd);
	return 1;
}

//关闭屏幕和解映射
int uninit_lcd()
{
	free(p);
	p = NULL;
	int n = munmap(plcd, 480 * 800 * 4);
	close(lcd_fd);

	return 1;
}


//图片显示
int display_bmp(int x0, int y0)
{
	unsigned char a, r, g, b;
	int x, y;//x行，y列
	int i = 0;
	int color = 0;



	if (abs(width) * (depth / 8) % 4)
	{
		laizi1 = 4 - abs(width) * (depth / 8) % 4;
	}

	for (y = 0; y < abs(height); y++)
	{
		for (x = 0; x < abs(width); x++)
		{
			b = p[i++];
			g = p[i++];
			r = p[i++];
			if (depth == 32)
			{
				a = p[i++];
			}
			else if (depth == 24)
			{
				a = 0;
			}

			color = ((a << 24) | (r << 16) | (g << 8) | b);
			lcd_draw_point(width > 0 ? x + x0 : abs(width) - 1 - x + x0, height > 0 ? abs(height) - 1 - y + y0 : y + y0, color);
		}
		i += laizi1;
	}
}

//映射
void lcd_draw_point(int i, int j, int color)
{
	if (i >= 0 && i < 800 && j >= 0 && j < 480)
	{
		*(plcd + j * 800 + i) = color;
	}
}

//void lcd_draw_number()
//{
//
//}
//字模
void draw_word(int x0, int y0, int w, int h, int color, char s[])
{
	//遍历数组的每个元素（1个字节 代表每行的8个像素素点的显示信息）
	int i, j;
	int arrary_num = w / 8 * h;

	for (i = 0; i < arrary_num; i++)
	{
		//每一个数组元素的每一位代表了一个像素点 从高到低

		//遍历它的每一位
		for (j = 7; j >= 0; j--)
		{
			/*
			判断该位是不是1
			s[i]>>j & 1 是否 >0
			1000 0000 >> 7 =>0000 0001
			0000 0001
		&	0000 0001
			0000 0001 >0
			*/
			if (*(s + i) >> j & 1)
			{
				//在屏幕对应的位置显示即可
				lcd_draw_point(i % (w / 8) * 8 + 7 - j + y0, i / (w / 8) + x0, color);
			}
		}
	}
}

//触摸屏
int get_xy()
{
	read_x = -1;
	read_y = -1;

	//int read_x, read_y;

	struct input_event ts;

	int touch_fd = open("/dev/input/event0", O_RDONLY);

	while (1)
	{
		//sleep(1);
		read(touch_fd, &ts, sizeof(struct input_event));

		if (ts.type == EV_KEY && ts.code == BTN_TOUCH)
		{
			if (ts.value == 1)
			{
				printf("press\n");
			}
			else
			{
				printf("release\n");
			}
		}

		if (ts.type == EV_ABS)
		{
			if (ts.code == ABS_X)
			{
				read_x = ts.value * 800 / 1024;
				ret_x = read_x;
				printf("x:%d\n", ret_x);
			}

			if (ts.code == ABS_Y)
			{
				read_y = ts.value * 480 / 600;
				ret_y = read_y;
				printf("y:%d\n", ret_y);

				break;
			}
		}
	}

	close(touch_fd);
}

//
void bmp_switch()
{
	if (read_x != -1 && read_y != -1 && start_all == 1)
	{
		start_all = 0;
		read_data(2);
		display_bmp(0, 0);
	}
	else if (start_all == 0)
	{
		//mp3
		if (read_x >= 300 && read_x <= 450 && read_y >= 170 && read_y <= 310
			&& start_all == 0 && flag_light != 1 && flag_mp3 == 0 && flag_dc != 1)
		{
			flag_mp3 = 1;
			if (music_start == 1 && flag_cont_music == 1)
			{
				read_data(7);
				display_bmp(0, 0);
			}
			else
			{
				read_data(3);
				display_bmp(0, 0);
			}

		}
		if (read_x >= 760 && read_x <= 800 && read_y >= 0 && read_y <= 60
			&& start_all == 0 && flag_light != 1 && flag_mp3 == 1 && flag_dc != 1)
		{
			system("killall -9 madplay ");
			flag_mp3 = 0;
			flag_cont_music = -1;
			music_start = 0;
			read_data(2);//回到首页
			display_bmp(0, 0);
		}

		//灯
		if (read_x >= 60 && read_x <= 200 && read_y >= 170 && read_y <= 310
			&& start_all == 0 && flag_light == 0 && flag_mp3 != 1 && flag_dc != 1)
		{
			if (flag_light_sys == 1)
			{
				//system("insmod led.ko");
				flag_light_sys = -flag_light_sys;
			}

			flag_light = 1;
			if (flag_on_off == -1)
			{
				read_data(5);//灯暗
				display_bmp(0, 0);
			}
			else
			{
				read_data(4);//灯亮
				display_bmp(0, 0);
			}

		}

		if (read_x >= 300 && read_x <= 450 && read_y >= 170 && read_y <= 310
			&& start_all == 0 && flag_light == 1 && flag_mp3 != 1 && flag_dc != 1)
		{

			//printf("%d\n",flag_on_off);
			if (flag_on_off == 1)
			{
				read_data(5);
				display_bmp(0, 0);
				// led_ctrl(LED_ALL, 1);
			}
			else if (flag_on_off == -1)
			{
				read_data(4);
				display_bmp(0, 0);
				// led_ctrl(LED_ALL, 0);
			}
			flag_on_off = -flag_on_off;
		}

		//温湿度
		if (read_x >= 550 && read_x <= 700 && read_y >= 170 && read_y <= 310
			&& start_all == 0 && flag_light != 1 && flag_mp3 != 1 && flag_dc == 0)
		{
			flag_dc = 1;
			//read_data(6);
			//display_bmp(0, 0);
		}
		if (read_x >= 650 && read_x <= 800 && read_y >= 310 && read_y <= 480)
		{
			motor();
			// read_data(6);
			// display_bmp(0, 0);
		}
		
		//返回
		if (read_x >= 0 && read_x <= 40 && read_y >= 0 && read_y <= 60)
		{
			if (start_all == 0 && flag_light != 1 && flag_mp3 == 1 && flag_dc != 1)
			{
				flag_mp3 = 0;
				read_data(2);
				display_bmp(0, 0);
			}
			else if (start_all == 0 && flag_light == 1 && flag_mp3 != 1 && flag_dc != 1)
			{
				flag_light = 0;
				read_data(2);
				display_bmp(0, 0);
			}
			else if (start_all == 0 && flag_light != 1 && flag_mp3 != 1 && flag_dc == 1)
			{
				flag_dc = 0;
				read_data(2);
				display_bmp(0, 0);
			}
		}
	}
}

//触摸滑动
int slide_touch()
{
	int read_x1 = -1, read_y1 = -1;
	int read_x2 = -1, read_y2 = -1;

	struct input_event ts1;

	int touch_fd = open("/dev/input/event0", O_RDONLY);

	while (1)
	{
		read(touch_fd, &ts1, sizeof(struct input_event));

		if (ts1.type == EV_KEY && ts1.code == BTN_TOUCH)
		{
			if (ts1.value == 1)
			{
				printf("press\n");
			}
			else
			{
				printf("relse\n");
				if (read_x2 >= 0 && read_y2 >= 0)
				{
					break;
				}
			}
		}

		if (ts1.type == EV_ABS)
		{
			if (ts1.code == ABS_X)
			{
				if (read_x1 >= 0 && read_y1 >= 0)
				{
					read_x2 = ts1.value * 800 / 1024;
				}
				else
				{
					read_x1 = ts1.value * 800 / 1024;
				}
			}
			if (ts1.code == ABS_Y)
			{
				read_y = ts1.value * 480 / 600;
				if (read_x1 >= 0 && read_y1 >= 0)
				{
					read_y2 = ts1.value * 480 / 600;
				}
				else
				{
					read_y1 = ts1.value * 480 / 600;
				}
			}
		}
	}
	//判断滑动方向
	if (abs(read_x1 - read_x2) > abs(read_y1 - read_y2) && read_x1 < read_x2) // 右滑
	{
		return 1;
	}
	else if (abs(read_x1 - read_x2) > abs(read_y1 - read_y2) && read_x1 > read_x2)
	{
		return 0;
	}
}

//led控制函数
void led_ctrl(char* led_id, int on_or_off)
{
	printf("%d\n", on_or_off);
	led_fd = open(led_id, O_RDWR);

	write(led_fd, &on_or_off, 4);

	close(led_fd);
}




//音乐
int music_play()
{
	int input = 0;

	char cmd[250] = { 0 };

	//需要你们写一段代码去播放MP3
	//上一首 下一首 暂停播放 继续播放 停止播放
	if (flag_mp3 == 1)
	{
		if (read_x >= 220 && read_x <= 260 && read_y >= 380 && read_y <= 440)
		{
			if (music_start == 1)
			{
				system("killall -9 madplay ");
			}
			printf("music_start = %d\n", music_start);

			if (music_count == 0)
			{
				music_count = 6;
			}
			else
			{
				music_count--;
			}
			printf("music_count = %d\n", music_count);
			//read_data(7);
			//display_bmp(0, 0);

			sprintf(cmd, "madplay %s -r &", mp3[music_count]);
			music_start = 1;
			system(cmd);
			flag_cont_music = 1;
		}
		else if (read_x >= 540 && read_x <= 580 && read_y >= 380 && read_y <= 430)
		{
			if (music_start == 1)
			{
				printf("播放终止\n");
				system("killall -9 madplay ");
			}
			printf("music_start = %d\n", music_start);

			if (music_count == 6)
			{
				music_count = 0;
			}
			else
			{
				music_count++;
			}
			printf("music_count = %d\n", music_count);

			read_data(7);
			display_bmp(0, 0);

			sprintf(cmd, "madplay %s -r &", mp3[music_count]);
			music_start = 1;
			system(cmd);
			flag_cont_music = 1;
		}
		else if (read_x >= 350 && read_x <= 450 && read_y >= 370 && read_y <= 480)
		{
			if (music_start == 0)
			{
				printf("开始播放\n");
				read_data(7);
				display_bmp(0, 0);
				sprintf(cmd, "madplay %s -r &", mp3[music_count]);
				system(cmd);
				music_start = 1;
			}
			else if (music_start == 1 && flag_cont_music == 1)
			{
				printf("暂停播放\n");
				read_data(7);
				display_bmp(0, 0);
				system("killall -STOP madplay &");
				flag_cont_music = -flag_cont_music;
			}
			else if (music_start == 1 && flag_cont_music == -1)
			{
				printf("继续播放\n");
				read_data(7);
				display_bmp(0, 0);
					
				system("killall -CONT madplay &");
				flag_cont_music = -flag_cont_music;
			}
		}

	}

}


void init_tty(int fd)
{
	//声明设置串口的结构体
	struct termios termios_new;
	//先清空该结构体
	bzero(&termios_new, sizeof(termios_new));
	//	cfmakeraw()设置终端属性，就是设置termios结构中的各个参数。
	cfmakeraw(&termios_new);
	//设置波特率
	//termios_new.c_cflag=(B9600);
	cfsetispeed(&termios_new, B9600);
	cfsetospeed(&termios_new, B9600);
	//CLOCAL和CREAD分别用于本地连接和接受使能，因此，首先要通过位掩码的方式激活这两个选项。    
	termios_new.c_cflag |= CLOCAL | CREAD;
	//通过掩码设置数据位为8位
	termios_new.c_cflag &= ~CSIZE;
	termios_new.c_cflag |= CS8;
	//设置无奇偶校验
	termios_new.c_cflag &= ~PARENB;
	//一位停止位
	termios_new.c_cflag &= ~CSTOPB;
	tcflush(fd, TCIFLUSH);
	// 可设置接收字符和等待时间，无特殊要求可以将其设置为0
	termios_new.c_cc[VTIME] = 10;
	termios_new.c_cc[VMIN] = 1;
	// 用于清空输入/输出缓冲区
	tcflush(fd, TCIFLUSH);
	//完成配置后，可以使用以下函数激活串口设置
	if (tcsetattr(fd, TCSANOW, &termios_new))
		printf("Setting the serial1 failed!\n");

}


//数字显示
void lcd_number(int x0, int y0, double lf)
{
	char* number_string = (char*)calloc(sizeof(char), 50);
	if (NULL == number_string)
	{
		perror("malloc fail");
		return;
	}
	sprintf(number_string, "%.2lf", lf);
	printf("number_string = %s\n", number_string);
	//strlen(number_string);
	char* cur = number_string;
	int n = 0;
	int displayce = 10;
	while (*cur)
	{
		if (*cur != '.')
		{
			n = *cur - '0';
		}
		else
		{
			n = 10;
		}

		displayce += 20;
		draw_word(y0, x0 + displayce, 24, 48, 0x050505, number[n]);
		cur++;
	}

	
	free(number_string);
	number_string = NULL;
}
void *gy39_fun(void *arg)
{
	int uart_fd = (int)*(int *)arg;
	
	gy39_send(uart_fd);
}

//串口打开
int uart_open(const char *path)
{
	int fd = open(path, O_RDWR);
	if(fd == -1)
	{
		perror("打开串口失败!");
		return -1;
	}
	
	return fd;
}

//串口初始化
int uart_init(int uart_fd)
{
	struct termios old_cfg,new_cfg;
	
	//1.保存原先串口配置
	int ret = tcgetattr(uart_fd,&old_cfg);
	if(ret == -1)
	{
		perror("保存原先串口配置失败");
		return -1;
	}
	
	//2.激活选项
	cfmakeraw(&new_cfg);
	new_cfg.c_cflag |= CLOCAL | CREAD;
	
	//3.设置波特率,9600
	cfsetispeed(&new_cfg, B9600);
	cfsetospeed(&new_cfg, B9600);
	
	//4.设置字符大小,数据位8位
	new_cfg.c_cflag &= ~CSIZE;	//清空原来的数据位
	new_cfg.c_cflag |= CS8;
	
	//5.设置奇偶校验位,无校验
	new_cfg.c_cflag &= ~PARENB;
	
	//6.停止位,1位
	new_cfg.c_cflag &= ~CSTOPB;
	
	//7.设置最少字符和等待时间
	new_cfg.c_cc[VTIME] = 0;
	new_cfg.c_cc[VMIN] = 1;
	
	//8.清空串口缓冲
	tcflush(uart_fd, TCIFLUSH);
	
	//9.激活配置
	ret = tcsetattr(uart_fd, TCSANOW,&new_cfg);
	if(ret == -1)
	{
		perror("串口激活配置失败");
		return -1;
	}
	return 0;
}
//gy39发送命令
void gy39_send(int uart_fd)
{
	//发送的命令
	char cmd_buf[3] = {0xa5,0x83,0x28};
	
	while(1)
	{
		write(uart_fd, cmd_buf, 3);
		//sleep(1);
		gy39_recv(uart_fd);
		sleep(1);
	}
}
void gy39_recv(int uart_fd)
{
	char ch;
	int data_len = 0;	//数据长度
	int gy39_i = 0;		//数组下标
	char gy39_buf[16] = {0};	//接收的数组
	enum gy39_flag gy39_flag;	
	gy39_flag = gy39_begin;
	if(flag_dc == 1)
	{
		read_data(6);
		display_bmp(0, 0);
	while(1)
	{
		read(uart_fd, &ch, 1);
		if(gy39_flag == gy39_begin)
		{
			//接收到第一个5a
			if(ch == 0x5a)
			{
				gy39_buf[gy39_i++] = ch;
				gy39_flag = gy39_5a_1;
			}
		}
		else if(gy39_flag == gy39_5a_1)
		{
			//接收到第二个5a
			if(ch == 0x5a)
			{
				gy39_buf[gy39_i++] = ch;
				gy39_flag = gy39_5a_2;
			}
			else
			{
				gy39_i = 0;
				gy39_flag = gy39_begin;
			}
		}
		else if(gy39_flag == gy39_5a_2)
		{
			//接收到数据类型
			if(ch == 0x15 || ch == 0x45 || ch == 0x55)
			{
				gy39_buf[gy39_i++] = ch;
				gy39_flag = gy39_type;
			}
			else
			{
				gy39_i = 0;
				gy39_flag = gy39_begin;
			}
		}
		else if(gy39_flag == gy39_type)
		{
			//接收到数据长度
			if(ch == 0x04 || ch == 0x0a || ch == 0x01)
			{
				gy39_buf[gy39_i++] = ch;
				gy39_flag = gy39_len;
				data_len = ch;
			}
			else
			{
				gy39_i = 0;
				gy39_flag = gy39_begin;
			}
		}
		else if(gy39_flag == gy39_len)
		{
			//接收数据
			gy39_buf[gy39_i++] = ch;
			data_len--;
			if(data_len == 0)
			{
				//数据信息接收完毕
				gy39_flag = gy39_data;
			}
		}
		else if(gy39_flag == gy39_data)
		{
			//接收到校验和
			gy39_buf[gy39_i++] = ch;
			gy39_flag = gy39_and;
			break;
		}
	}
	
	int i;
	printf("===================================\n");
	printf("data:");
	for(i = 0; i < 16; i++)
	{
		printf("%x ", gy39_buf[i]);
	}
	printf("\n");
	printf("===================================\n");
	char show_gy39[50];
	char Lux_show[50];
	if (gy39_buf[2] == 0x15)
	{
		//光照强度
		int Lux = (gy39_buf[4]<<24)|(gy39_buf[5]<<16)|(gy39_buf[6]<<8)|gy39_buf[7];
		/****光强*****/
		bzero(Lux_show,sizeof(Lux));
		sprintf(Lux_show, "Lux=%.2flux", Lux/100.0f);
		send_L = Lux/100.0f;
		if(Lux/100.0f > 100)
		{
			Clean_Area(400,130,240,40,0x00);
			Display_characterX(400,130,"当前光照过强，请做好遮阳",0xffffff,1);
		}
		
		
	}
	else if(gy39_buf[2] == 0x45)
	{
		int T = (gy39_buf[4]<<8)|gy39_buf[5];	//温度
		int P = (gy39_buf[6]<<24)|(gy39_buf[7]<<16)|(gy39_buf[8]<<8)|gy39_buf[9];	//气压
		int Hum = (gy39_buf[10]<<8)|gy39_buf[11];	//湿度
		int H = (gy39_buf[12]<<8)|gy39_buf[13];		//海拔
		send_T = T/100.0f;
		send_P = P/100.0f;
		send_M = Hum/100.0f;
		send_H = H/100.0f;
		Clean_Area(400,90,240,40,0x00);
		Display_characterX(400,90,Lux_show,0xffffff,2);
		/****温度*****/
		bzero(show_gy39,sizeof(show_gy39));
		sprintf(show_gy39, "T=%.2fC", T/100.0f);
		Clean_Area(50,90,240,80,0x00);
		Display_characterX(50,90,show_gy39,0xffffff,2);
		/****气压*****/
		bzero(show_gy39,sizeof(show_gy39));
		sprintf(show_gy39, "P=%.2fPa", P/100.0f);
		Clean_Area(50,170,240,80,0x00);
		Display_characterX(50,170,show_gy39,0xffffff,2);
		/****湿度*****/
		bzero(show_gy39,sizeof(show_gy39));
		sprintf(show_gy39, "Hum=%.2f%%", Hum/100.0f);
		Clean_Area(50,250,240,80,0x00);
		Display_characterX(50,250,show_gy39,0xffffff,2);
		/****海拔*****/
		bzero(show_gy39,sizeof(show_gy39));
		sprintf(show_gy39, "H=%dm", H);
		Clean_Area(50,330,240,80,0x00);
		Display_characterX(50,330,show_gy39,0xffffff,2);
		if(T/100.0f > 30)
		{
			motor();
			Clean_Area(400, 170, 240, 40, 0x00);
			Display_characterX(400,170,"当前温度过高，已开启降温措施",0xffffff,1);
		}
		

	}
	}
	
}
